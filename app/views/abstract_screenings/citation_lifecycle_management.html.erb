<script src="/echarts.min.js"></script>
<div x-data="citation_lifecycle_management">
  <div class="flex items-center space-x-2 ml-7">
    <div
      @click="tab = 'extractionOverview'"
      class="bg-srdrpurple-light text-white m-1 p-2 rounded-md cursor-pointer"
      :class="{ '!bg-srdrpurple': tab === 'extractionOverview' }"
    >
      Extraction Overview
    </div>
    <div
      @click="tab = 'citationLifecycleManagement'"
      class="bg-srdrpurple-light text-white m-1 p-2 rounded-md cursor-pointer"
      :class="{ '!bg-srdrpurple': tab === 'citationLifecycleManagement' }"
    >
      Citation Lifecycle Management
    </div>
    <div
      @click="tab = 'projectMessages'; if (Notification.permission !== 'granted') { Notification.requestPermission() };"
      class="bg-srdrpurple-light text-white m-1 p-2 rounded-md cursor-pointer"
      :class="{ '!bg-srdrpurple': tab === 'projectMessages' }"
    >
      All Message Boards
    </div>
  </div>
  <div class="px-4 lg:px-8 py-2 lg:py-4">
    <div x-cloak x-show="tab === 'extractionOverview'">
      <%= render 'projects/status' %>
    </div>
    <div x-cloak x-show="tab === 'citationLifecycleManagement'">
      <%= render 'citation_lifecycle_management' %>
    </div>
    <div x-cloak x-show="tab === 'projectMessages'">
      <%= render 'projects/project_messages' %>
    </div>
  </div>
</div>
<script>
  function copyAllTextToClipboard(text) {
    const textarea = document.createElement("textarea");
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);
  }

  document.addEventListener("alpine:init", () => {
    Alpine.data("citation_lifecycle_management", () => ({
      results: null,
      query: "",
      base_url:
        "/projects/<%= params[:project_id] %>/citation_lifecycle_management",
      pagination: {
        base_url: this.base_url,
        prev_page: "",
        current_page: "",
        next_page: "",
        total_pages: "",
        query: null,
        order_by: null,
        sort: null,
      },
      selected: [],
      users: [],
      showLoading: false,
      showDetailView: false,
      showCreateExtractions: false,
      showCitationsInRis: false,
      showCopyModal: false,
      selectedExtractionId: null,
      userProjects: [],
      projectCompatibility: {},
      detailedResult: 0,
      lastIndexSelected: null,
      copied: false,
      tab: "extractionOverview",
      showSearchHelp: false,

      init() {
        window.shift = false;
        window.onkeyup = () => (window.shift = false);
        window.onkeydown = () => (window.shift = true);
        this.fetch_results();
        this.fetchUserProjects();
        this.$watch("query", (value, oldValue) => {
          this.pagination.current_page = 1;
          this.pagination.query = value;
          this.pagination.order_by = null;
          this.pagination.sort = null;
          this.fetch_results();
        });
      },

      copyText() {
        const textToCopy =
          document.getElementById("citationInRisModal").innerText;
        copyAllTextToClipboard(textToCopy);
        this.copied = true;

        // Reset the "Copied!" text after a short delay (e.g., 3 seconds)
        setTimeout(() => {
          this.copied = false;
        }, 3000);
      },

      async fetchUserProjects() {
        try {
          const response = await fetch("/projects/user_projects", {
            method: "GET",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              "X-Requested-With": "XMLHttpRequest",
              "X-CSRF-Token": document.querySelector("[name='csrf-token']")
                .content,
            },
          });

          if (!response.ok) {
            console.error(`Error: ${response.status} - ${response.statusText}`);
            return;
          }

          const data = await response.json();
          this.userProjects = data.map((project) => ({
            ...project,
            showDifferences: false,
          }));
        } catch (error) {
          console.error("An error occurred:", error);
        }
      },

      async checkExtractionCompatibility() {
        if (!this.selectedExtractionId || this.userProjects.length === 0) {
          return;
        }

        // Reset compatibility status
        this.projectCompatibility = {};

        // Set all projects to loading state
        this.userProjects.forEach((project) => {
          this.projectCompatibility[project.id] = { status: "loading" };
        });

        try {
          const projectIds = this.userProjects.map((p) => p.id);
          const queryString = projectIds
            .map((id) => `target_project_ids[]=${id}`)
            .join("&");

          const response = await fetch(
            `/extractions/${this.selectedExtractionId}/check_compatibility?${queryString}`,
            {
              method: "GET",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "X-CSRF-Token": document.querySelector("[name='csrf-token']")
                  .content,
              },
            }
          );

          if (!response.ok) {
            console.error(`Error: ${response.status} - ${response.statusText}`);
            // Set all to error state
            this.userProjects.forEach((project) => {
              this.projectCompatibility[project.id] = {
                status: "error",
                error: "Failed to check compatibility",
              };
            });
            return;
          }

          const results = await response.json();

          // Update compatibility status for each project
          results.forEach((result) => {
            this.projectCompatibility[result.project_id] = {
              status: "loaded",
              compatible: result.compatible,
              differences: result.differences || [],
              error: result.error,
            };
          });
        } catch (error) {
          console.error("An error occurred:", error);
          // Set all to error state
          this.userProjects.forEach((project) => {
            this.projectCompatibility[project.id] = {
              status: "error",
              error: "Network error",
            };
          });
        }
      },

      getCompatibilityStatus(projectId) {
        return this.projectCompatibility[projectId] || { status: "loading" };
      },

      isCompatibilityLoading(projectId) {
        const status = this.getCompatibilityStatus(projectId);
        return status.status === "loading";
      },

      isCompatible(projectId) {
        const status = this.getCompatibilityStatus(projectId);
        return status.status === "loaded" && status.compatible === true;
      },

      hasIncompatibility(projectId) {
        const status = this.getCompatibilityStatus(projectId);
        return status.status === "loaded" && status.compatible === false;
      },

      hasCompatibilityError(projectId) {
        const status = this.getCompatibilityStatus(projectId);
        return status.status === "error";
      },

      getCompatibilityMessage(projectId) {
        const status = this.getCompatibilityStatus(projectId);
        if (status.status === "loading") return "Checking compatibility...";
        if (status.status === "error")
          return status.error || "Error checking compatibility";
        if (status.compatible) return "Compatible";
        return "Incompatible extraction form";
      },

      applyTdBg(screening_status) {
        if (screening_status == "ec") {
          return "!bg-green-200";
        } else if (screening_status.indexOf("p") != -1) {
          return "!bg-slate-200";
        } else if (screening_status.indexOf("ic") != -1) {
          return "!bg-orange-200";
        } else if (screening_status.indexOf("r") != -1) {
          return "!bg-red-200";
        }
      },

      toggleSelection(resultsIndex) {
        if (!window.shift) {
          this.lastIndexSelected = resultsIndex;
        }

        let head = null;
        let tail = null;
        if (resultsIndex >= this.lastIndexSelected) {
          head = this.lastIndexSelected;
          tail = resultsIndex;
        } else {
          head = resultsIndex;
          tail = this.lastIndexSelected;
        }
        if (window.shift && tail == resultsIndex) {
          head += 1;
        } else if (window.shift && head == resultsIndex) {
          tail -= 1;
        }
        for (i = head; i <= tail; i++) {
          if (
            !this.selected.some(
              (selectedCp) =>
                selectedCp.citations_project_id ==
                this.results[i].citations_project_id
            )
          ) {
            this.selected.push(this.results[i]);
          } else {
            this.selected = this.selected.filter(
              (selectedCp) =>
                selectedCp.citations_project_id !=
                this.results[i].citations_project_id
            );
          }
        }
        this.lastIndexSelected = resultsIndex;
      },

      changeOrderBy(order_by) {
        if (this.pagination.order_by == order_by) {
          if (this.pagination.sort == "asc") {
            this.pagination.sort = "desc";
          } else if (this.pagination.sort == "desc") {
            this.pagination.order_by = null;
            this.pagination.sort = null;
          } else {
            this.pagination.sort = "asc";
          }
        } else {
          this.pagination.sort = "asc";
          this.pagination.order_by = order_by;
        }
        this.fetch_results();
      },

      goToPage(page) {
        this.pagination.current_page = page;
        this.fetch_results();
      },

      query_url() {
        let url = this.base_url;
        let params = [];
        if (this.pagination.query) {
          params.push("query=" + escape(this.pagination.query));
        }
        if (this.pagination.order_by) {
          params.push("order_by=" + this.pagination.order_by);
        }
        if (this.pagination.sort) {
          params.push("sort=" + this.pagination.sort);
        }
        params.push(`page=${this.pagination.current_page}`);
        return url + "?" + params.join("&");
      },

      async loadSelectedCitationsInRis() {
        try {
          this.showloading = true;

          const response = await fetch(
            "/projects/<%= params[:project_id] %>/citations_in_ris",
            {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "X-CSRF-Token": document.querySelector("[name='csrf-token']")
                  .content,
              },
              body: JSON.stringify({
                project: {
                  citation: this.selected.map((cp) => cp.citation_id),
                },
              }),
            }
          );

          if (!response.ok) {
            console.error(`Error: ${response.status} - ${response.statusText}`);
            return;
          }

          const data = await response.json();

          let risModalPre = document.getElementById("citationInRisModal");
          risModalPre.innerText = data.payload;
        } catch (error) {
          console.error("An error occurred:", error);
        } finally {
          this.showloading = false;
        }
      },

      async createExtractions() {
        this.showLoading = true;
        const selectedUsers = [];
        this.users.forEach((user) => {
          if (user.selected) {
            selectedUsers.push(user);
          }
        });
        for (const user of selectedUsers) {
          const response = await fetch(
            "/projects/<%= params[:project_id] %>/extractions",
            {
              method: "POST",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
                "X-Requested-With": "XMLHttpRequest",
                "X-CSRF-Token": document.querySelector("[name='csrf-token']")
                  .content,
              },
              body: JSON.stringify({
                extraction: {
                  citation: this.selected.map((cp) => cp.citation_id),
                  user_id: user.id,
                  noDuplicates: true,
                },
              }),
            }
          );
          if (response.status == 403) {
            toastr.error("Sorry, you are not authorized", null, {
              timeOut: 1000,
            });
            this.showLoading = false;
          } else if (response.status < 200 || response.status >= 300) {
            toastr.error("Sorry, an error occurred", null, {
              timeOut: 1000,
            });
            this.showLoading = false;
          }
          const data = await response.json();
          if (data.success.citation_names.length > 0) {
            toastr.success(
              data.success.citation_names.join("\n\n"),
              `${data.success.user_handle} has been assigned`
            );
          }
          if (data.error.citation_names.length > 0) {
            toastr.error(
              data.error.citation_names.join("\n\n"),
              `${data.error.user_handle} encountered errors when assigning`
            );
          }
          if (data.info.citation_names.length > 0) {
            toastr.info(
              data.info.citation_names.join("\n\n"),
              `${data.info.user_handle} has skipped assignments (already exists)`
            );
          }
        }
        this.showLoading = false;
      },

      async createScreeningQualification(qualification_type) {
        this.showLoading = true;
        const response = await fetch("/screening_qualifications", {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "X-CSRF-Token": document.querySelector("[name='csrf-token']")
              .content,
          },
          body: JSON.stringify({
            qualification_type,
            citations_project_ids: this.selected.map(
              (cp) => cp.citations_project_id
            ),
          }),
        });
        if (response.status == 403) {
          toastr.error("Sorry, you are not authorized", null, {
            timeOut: 1000,
          });
          this.showLoading = false;
        } else if (response.status < 200 || response.status >= 300) {
          toastr.error("Sorry, an error occurred", null, {
            timeOut: 1000,
          });
          this.showLoading = false;
        }
        const data = await response.json();
        data.forEach((screeningStatus) => {
          this.selected.forEach((selection) => {
            if (
              selection.citations_project_id ==
              screeningStatus.citations_project_id
            ) {
              selection.screening_status = screeningStatus.screening_status;
              selection.abstract_qualification =
                screeningStatus.abstract_qualification;
              selection.fulltext_qualification =
                screeningStatus.fulltext_qualification;
              selection.extraction_qualification =
                screeningStatus.extraction_qualification;
            }
          });
          this.results.forEach((result) => {
            if (
              result.citations_project_id ==
              screeningStatus.citations_project_id
            ) {
              result.screening_status = screeningStatus.screening_status;
              result.abstract_qualification =
                screeningStatus.abstract_qualification;
              result.fulltext_qualification =
                screeningStatus.fulltext_qualification;
              result.extraction_qualification =
                screeningStatus.extraction_qualification;
              result.consolidation_qualification =
                screeningStatus.consolidation_qualification;
            }
          });
        });
        Alpine.store("dashboard").fetch_kpis();
        this.showLoading = false;
        this.selected = [];
      },

      async fetch_results() {
        const response = await fetch(this.query_url(), {
          method: "GET",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
          },
        });
        const data = await response.json();
        const allResults = this.selected.concat(data.results);
        const uniqueResults = [];
        const lookup = {};
        allResults.forEach((result) => {
          if (!(result.citations_project_id in lookup)) {
            lookup[result.citations_project_id] = true;
            uniqueResults.push(result);
          }
        });
        this.results = uniqueResults;
        this.pagination = data.pagination;
        this.users = data.users;
      },

      async update_evaluation(citations_project_id, type) {
        const response = await fetch(
          `/citations_projects/${citations_project_id}/update_evaluation?page=<%= params[:page] %>&type=${type}`,
          {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
          }
        );
        const data = await response.json();
        for (let i = 0; i < this.results.length; i++) {
          const citations_project = this.results[i];
          if (
            citations_project.citations_project_id == data.citations_project_id
          ) {
            citations_project.screening_status = data.screening_status;
          }
        }
        Alpine.store("dashboard").fetch_kpis();
      },
    }));
  });
</script>
