<div
  class="overflow-hidden"
  x-data="screenStore"
  @keyup.escape.window="closeAllModals()"
>
  <!-- prettier-ignore -->
  <%= render 'abstract_screenings/screen/add_reasoning' %>
  <%= render 'abstract_screenings/screen/weighing_screen' %>
  <%= render 'abstract_screenings/screen/confirmation_modal' %>
  <%= render 'abstract_screenings/screen/history_panel' %>
  <div
    :class="desktop ? 'top-0 bottom-24 border-l border-b border-gray-600 fixed p-4 left-2/3 right-0 overflow-y-scroll overflow-x-hidden bg-white' : ''"
  >
    <!-- prettier-ignore -->
    <%= render 'abstract_screenings/screen/reasoning_menu' %>
    <%= render 'abstract_screenings/screen/screening_form' %>
    <%= render 'abstract_screenings/screen/word_weight_menu' %>
  </div>
  <div
    class="mx-auto lg:mx-0 lg:w-2/3 h-24 absolute inset-0 overflow-y-hidden bg-gray-300 flex flex-col justify-center"
  >
    <a
      href="<%= abstract_screening_path(params[:abstract_screening_id]) %>"
      class="cursor-pointer z-[5] absolute top-4 right-4 bg-gray-100 rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
    >
      <span class="sr-only">Close menu</span>
      <!-- Heroicon name: outline/x -->
      Exit
    </a>
    <button
      type="button"
      :class="desktop ? 'hidden' : 'cursor-pointer z-[5] absolute top-14 right-4 bg-gray-100 rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500'"
      @click="word_weight_menu = !word_weight_menu"
    >
      <span class="sr-only">Word weights</span>
      Terms & Phrases
    </button>
    <button
      @click="historyPanel = true"
      class="cursor-pointer z-[5] absolute top-4 right-16 bg-gray-100 rounded-md p-2 inline-flex items-center justify-center text-gray-400 hover:text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500"
    >
      Past Labels
    </button>
    <div class="h-24 mr-44 overflow-y-auto flex items-center">
      <div
        class="horizontal-scroll-wrapper"
        @mouseup="checkSelection()"
        @touchend="checkSelection()"
      >
        <div class="flex items-center">
          <h1 class="px-8 text-base font-bold leading-none">
            <template x-for="word in processedTitle">
              <span
                :id="word.id"
                :class="if (word.type != 'nonWord') return `cursor-pointer hover:bg-yellow-200 ${cssWordClass[word.weight]}`"
                x-text="word.content"
                @click="if (word.type != 'nonWord') weighWord(word.phrase)"
              ></span>
            </template>
          </h1>
        </div>
      </div>
    </div>
  </div>
  <div
    class="mx-auto lg:mx-0 lg:w-2/3 h-auto block absolute inset-0 mt-24 overflow-y-auto overflow-x-hidden bg-gray-100"
    :class="desktop ? '' : 'mb-24'"
  >
    <div class="vertical-scroll-wrapper">
      <div class="vertical-scroll-wrapper-item">
        <div
          class="px-8 leading-5"
          @mouseup="checkSelection()"
          @touchend="checkSelection()"
        >
          <template x-for="word in processedAbstract">
            <span
              :id="word.id"
              :class="if (word.type != 'nonWord') return `cursor-pointer hover:bg-yellow-200 ${cssWordClass[word.weight]}`"
              x-text="word.content"
              @click="if (word.type != 'nonWord') weighWord(word.phrase)"
            ></span>
          </template>
        </div>
        <hr />
        <div
          class="px-8 break-all leading-none"
          x-text="citation.keywords"
        ></div>
        <div class="px-8 break-all leading-none" x-text="citation.id"></div>
        <div
          class="px-8 break-all leading-none"
          x-text="citation.journal_meta_info"
        ></div>
        <hr />
        <div class="px-8 leading-5 text-xs">
          <h5 class="text-sm font-bold">All Labels</h5>
          <template x-for="label in all_labels">
            <div class="flex">
              <div class="w-1/3 border" x-text="label.updated_at"></div>
              <div class="w-1/3 border" x-text="label.user_handle"></div>
              <div
                class="w-1/3 border"
                x-text="{ null: 'Unlabeled', '-1': 'Rejected', 0: 'Maybe', 1: 'Accepted' }[label.label]"
              ></div>
            </div>
          </template>
        </div>
      </div>
    </div>
  </div>

  <div
    :class="desktop ? 'hidden' : 'mx-auto lg:mx-0 lg:w-2/3 absolute bottom-0 left-0 right-0 bg-gray-100 h-24'"
  >
    <div class="h-full text-white">
      <div class="grid grid-cols-3 h-full">
        <div
          class="cursor-pointer border-r-8 bg-red-500 flex justify-center items-center rounded-tl-2xl"
          @click="asr.label = -1; if (requireReasoning()) { reasoningMenu = true } else { updateAsr('label') }"
          :class="(asr.label == -1 || asr.label == null) ? '' : 'saturate-[0.1]'"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-10 w-10"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
              clip-rule="evenodd"
            />
          </svg>
        </div>
        <div class="grid grid-rows-2">
          <div
            class="cursor-pointer border-b-4 bg-srdrpurple flex justify-center items-center"
            @click="asr.label = 0; if (requireReasoning()) { reasoningMenu = true } else { updateAsr('label') }"
            :class="(asr.label == 0 || asr.label == null)? '' : 'saturate-[0.1]'"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-10 w-10"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              stroke-width="2"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
          </div>
          <div
            class="cursor-pointer border-t-2 bg-gray-500 flex justify-center items-center"
            @click="asr.label = null; reasoningMenu = !reasoningMenu"
          >
            <div class="space-y-2">
              <div class="w-8 h-0.5 bg-white"></div>
              <div class="w-8 h-0.5 bg-white"></div>
              <div class="w-8 h-0.5 bg-white"></div>
            </div>
          </div>
        </div>
        <div
          class="cursor-pointer border-l-8 bg-green-500 flex justify-center items-center rounded-tr-2xl"
          @click="asr.label = 1; if (requireReasoning()) { reasoningMenu = true } else { updateAsr('label') }"
          :class="(asr.label == 1 || asr.label == null)? '' : 'saturate-[0.1]'"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-10 w-10"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z"
              clip-rule="evenodd"
            />
          </svg>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener("alpine:init", () => {
    Alpine.data("screenStore", () => ({
      desktop: false,
      weighingScreen: false,
      word_weight_menu: false,
      reasoningMenu: false,
      addReasonModal: { on: false, type: "", action: "" },
      historyPanel: false,
      confirmationModalLabel: null,
      confirmationModal: false,
      confirmationModalText: "",
      confirmationModalTexts: {
        "-1": "Rejected",
        0: "Maybe",
        1: "Accepted",
      },
      citation: {
        abstract_screening_id: "",
        citation_id: "",
        title: "",
        journal: "",
        authors: "",
        abstract: "",
        keywords: "",
        id: "",
        journal_meta_info: "",
      },
      options: {
        yes_tag_required: null,
        no_tag_required: null,
        maybe_tag_required: null,
        yes_reason_required: null,
        no_reason_required: null,
        maybe_reason_required: null,
        yes_note_required: null,
        no_note_required: null,
        maybe_note_required: null,
        only_predefined_reasons: null,
        only_predefined_tags: null,
      },
      asr: {
        id: null,
        label: null,
        predefined_reasons: [],
        predefined_tags: [],
        custom_reasons: [],
        custom_tags: [],
        notes: "",
      },
      all_labels: [],
      cps: [],
      word_weights: {},
      wordWeight: "",
      cssWordClass: {
        2: "text-green-500 font-black",
        1: "text-green-500",
        0: "",
        "-1": "text-red-500",
        "-2": "text-red-500 font-black",
      },
      textarea_keywords_and_phrases: "",
      newCustomValue: "",
      updateCustomId: null,
      processedTitle: [],
      processedAbstract: "",
      disable_textarea_keywords_and_phrases: false,
      dragIndex: null,
      dragType: null,
      dropIndex: null,
      dropType: null,

      init() {
        const url = new URL(window.location.href);
        const asr_id = url.searchParams.get("asr_id");
        const before_asr_id = url.searchParams.get("before_asr_id");
        this.getAsrId(asr_id, before_asr_id);

        const smallDevice = window.matchMedia("(min-width: 1024px)");
        smallDevice.addListener(handleDeviceChange);
        const that = this;
        function handleDeviceChange(e) {
          if (e.matches) {
            that.desktop = true;
          } else {
            that.desktop = false;
          }
        }
        handleDeviceChange(smallDevice);
      },

      toggleWeighingScreen() {
        this.weighingScreen = !this.weighingScreen;
      },

      requireReasoning() {
        return (
          (this.asr.label == -1 &&
            (this.options.no_tag_required ||
              this.options.no_reason_required ||
              this.options.no_note_required)) ||
          (this.asr.label == 0 &&
            (this.options.maybe_tag_required ||
              this.options.maybe_reason_required ||
              this.options.maybe_note_required)) ||
          (this.asr.label == 1 &&
            (this.options.yes_tag_required ||
              this.options.yes_reason_required ||
              this.options.yes_note_required))
        );
      },

      hasSomeReason() {
        return this.asr.predefined_reasons
          .concat(this.asr.custom_reasons)
          .some((v) => v.selected);
      },

      hasSomeTag() {
        return this.asr.predefined_tags
          .concat(this.asr.custom_tags)
          .some((v) => v.selected);
      },

      hasSomeNote() {
        return this.asr.notes.length > 0;
      },

      satisfiesReasoning() {
        if (this.asr.label == null) return false;
        let satisfactory = true;
        if (this.asr.label == -1) {
          if (this.options.no_tag_required)
            satisfactory = this.hasSomeTag() && satisfactory;
          if (this.options.no_reason_required)
            satisfactory = this.hasSomeReason() && satisfactory;
          if (this.options.no_note_required)
            satisfactory = this.hasSomeNote() && satisfactory;
        }
        if (this.asr.label == 0) {
          if (this.options.maybe_tag_required)
            satisfactory = this.hasSomeTag() && satisfactory;
          if (this.options.maybe_reason_required)
            satisfactory = this.hasSomeReason() && satisfactory;
          if (this.options.maybe_note_required)
            satisfactory = this.hasSomeNote() && satisfactory;
        }
        if (this.asr.label == 1) {
          if (this.options.yes_tag_required)
            satisfactory = this.hasSomeTag() && satisfactory;
          if (this.options.yes_reason_required)
            satisfactory = this.hasSomeReason() && satisfactory;
          if (this.options.yes_note_required)
            satisfactory = this.hasSomeNote() && satisfactory;
        }
        return satisfactory;
      },

      invalidCustomValue() {
        if (this.newCustomValue == "") {
          toastr.error("This field cannot be empty.");
          return true;
        }

        if (
          this.addReasonModal.type == "custom_reasons" &&
          (this.asr["custom_reasons"].some(
            (custom_reason) => custom_reason.name == this.newCustomValue
          ) ||
            this.asr["predefined_reasons"].some(
              (predefined_reason) =>
                predefined_reason.name == this.newCustomValue
            ))
        ) {
          toastr.error("This value has already been taken.");
          return true;
        }

        if (
          this.addReasonModal.type == "custom_tags" &&
          (this.asr["custom_tags"].some(
            (custom_tag) => custom_tag.name == this.newCustomValue
          ) ||
            this.asr["predefined_tags"].some(
              (predefined_tag) => predefined_tag.name == this.newCustomValue
            ))
        ) {
          toastr.error("This value has already been taken.");
          return true;
        }

        return false;
      },

      async createCustomValue() {
        let url;
        if (this.addReasonModal.type == "custom_reasons") {
          url =
            "/abstract_screenings/<%= params[:abstract_screening_id] %>/abstract_screenings_reasons_users";
        } else if (this.addReasonModal.type == "custom_tags") {
          url =
            "/abstract_screenings/<%= params[:abstract_screening_id] %>/abstract_screenings_tags_users";
        }
        const response = await fetch(url, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "X-CSRF-Token": document.querySelector("[name='csrf-token']")
              .content,
          },
          body: JSON.stringify({
            name: this.newCustomValue.trim(),
          }),
        });
        await response.json();
        await this.getAsr();
        this.addReasonModal.on = false;
        this.newCustomValue = "";
      },

      async updateCustomValue(type, values) {
        const id = values.id;
        const pos = values.pos;
        const newCustomValue = values.newCustomValue || false;
        let url;
        if (type == "custom_reasons") {
          url = `/abstract_screenings_reasons_users/${id}`;
        } else if (type == "custom_tags") {
          url = `/abstract_screenings_tags_users/${id}`;
        }
        const response = await fetch(url, {
          method: "PATCH",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "X-CSRF-Token": document.querySelector("[name='csrf-token']")
              .content,
          },
          body: JSON.stringify({
            pos,
            newCustomValue,
          }),
        });
        await response.json();
        await this.getAsr();
        this.addReasonModal.on = false;
        this.newCustomValue = "";
      },

      async deleteCustomValue(type, index) {
        const id = this.asr[type][index].id;
        if (
          confirm(
            `Would you like to delete "${this.asr[type][index].name}" as a custom choice?`
          )
        ) {
          let url;
          if (type == "custom_reasons") {
            url = `/abstract_screenings_reasons_users/${id}`;
          } else if (type == "custom_tags") {
            url = `/abstract_screenings_tags_users/${id}`;
          }
          const response = await fetch(url, {
            method: "DELETE",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              "X-Requested-With": "XMLHttpRequest",
              "X-CSRF-Token": document.querySelector("[name='csrf-token']")
                .content,
            },
            body: JSON.stringify({
              id,
              destroyExistingValues: true,
            }),
          });
          await response.json();
          await this.getAsr();
        }
      },

      closeAllModals() {
        if (this.addReasonModal.on) {
          this.addReasonModal.on = false;
        } else {
          this.weighingScreen = false;
          this.reasoningMenu = false;
          this.word_weight_menu = false;
        }
      },

      checkSelection() {
        const selection = window.getSelection().toString();
        this.weighWord(selection);
      },

      update_word_weight(event, id, weight) {
        const word = event.target.value;

        if (
          word.length == 0 ||
          (word in this.word_weights && this.word_weights[word].id != id)
        ) {
          event.target.classList.add("!bg-red-500");
          return;
        } else {
          event.target.classList.remove("!bg-red-500");
        }
        this.sendWw(word, weight, id);
        setTimeout(() => this.$focus.focus(event.target), 500);
      },

      weighWord(word) {
        if (word.length > 0 && word != " ") {
          this.weighingScreen = true;
          this.wordWeight = word;
          this.$nextTick(() => {
            this.$refs.wordWeightInput.focus();
          });
        }
      },

      checkLengthRestriction(event, maxLength) {
        if (event.target.value.length >= maxLength) {
          toastr.warning(`The input limit is ${maxLength}`);
        }
      },

      async process_textarea_keywords_and_phrases() {
        this.disable_textarea_keywords_and_phrases = true;
        const lines = this.textarea_keywords_and_phrases.split("\n");
        const unprocessable = [];
        for (const line of lines) {
          const lineParts = line.split(" ");
          const wordParts = lineParts.slice(0, -1);
          const weight = parseInt(lineParts.slice(-1));
          const word = wordParts.join(" ");
          if (
            word.length < 1 ||
            word.length > 50 ||
            weight === NaN ||
            [2, 1, 0, -1, -2].indexOf(weight) === -1
          ) {
            unprocessable.push(line);
            continue;
          }

          await this.sendWw(word, weight, null, weight === 0);
        }
        this.textarea_keywords_and_phrases = unprocessable.join("\n");
        this.disable_textarea_keywords_and_phrases = false;
        if (unprocessable.length > 0) {
          toastr.error("Some words or phrases could not be processed.");
        }
      },

      paste_textarea_keywords_and_phrases() {
        this.textarea_keywords_and_phrases = Object.keys(this.word_weights)
          .sort()
          .map((word) => {
            return word + " " + this.word_weights[word].weight;
          })
          .join("\n");
      },

      processWeights(sourceKey, destinationKey) {
        this[destinationKey] = [];
        const sourceText = this.citation[sourceKey];
        if (sourceText.length == 0) return;

        let sourceTextArray = Array(sourceText.length).fill(null);

        var regex = /(\w+)/gi;
        while ((match = regex.exec(this.citation[sourceKey])) != null) {
          for (let i = match.index; i < match.index + match[0].length; i++) {
            sourceTextArray[i] = {
              id: `word:${match.index}-${match.index + match[0].length}`,
              weight: 0,
              phrase: sourceText.slice(
                match.index,
                match.index + match[0].length
              ),
              type: "word",
            };
          }
        }

        var regex = /(\W+)/gi;
        while ((match = regex.exec(this.citation[sourceKey])) != null) {
          for (let i = match.index; i < match.index + match[0].length; i++) {
            sourceTextArray[i] = {
              id: `nonWord:${match.index}-${match.index + match[0].length}`,
              weight: 0,
              phrase: sourceText.slice(
                match.index,
                match.index + match[0].length
              ),
              type: "nonWord",
            };
          }
        }

        let matches = [];
        for (const phrase of Object.keys(this.word_weights)) {
          const word_weight = this.word_weights[phrase];
          var regex = new RegExp(phrase, "gi");
          while ((match = regex.exec(this.citation[sourceKey])) != null) {
            matches.push({
              head: match.index,
              tail: match.index + match[0].length,
              id: `match:${match.index}-${match.index + match[0].length}`,
              weight: word_weight.weight,
              phrase: phrase,
            });
          }
        }

        matches.sort(function compareFn(a, b) {
          if (a.tail - a.head > b.tail - b.head) return -1;
          if (a.tail - a.head < b.tail - b.head) return -1;
          return 0;
        });
        for (let i = 0; i < matches.length; i++) {
          let match = matches[i];
          for (let ii = match.head; ii < match.tail; ii++) {
            sourceTextArray[ii] = {
              id: match.id,
              weight: match.weight,
              phrase: match.phrase,
              type: "match",
            };
          }
        }

        let currentId = sourceTextArray[0] && sourceTextArray[0].id;
        let head = 0;
        for (let i = 1; i <= this.citation[sourceKey].length; i++) {
          let currentElement = sourceTextArray[i];
          if (currentElement == undefined || currentElement.id != currentId) {
            this[destinationKey].push({
              id: sourceTextArray[i - 1].id,
              weight: sourceTextArray[i - 1].weight,
              phrase: sourceTextArray[i - 1].phrase,
              type: sourceTextArray[i - 1].type,
              content: sourceText.slice(head, i),
            });
            head = i;
            currentId = currentElement && currentElement.id;
          }
        }
      },

      showConfirmation(label) {
        this.closeAllModals();
        this.confirmationModalLabel = label;
        this.confirmationModalText = this.confirmationModalTexts[label];
        this.confirmationModal = true;
      },

      async sendWw(word, weight, id, destroy) {
        const response = await fetch(
          "/abstract_screenings/<%= params[:abstract_screening_id] %>/update_word_weight",
          {
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
              "X-Requested-With": "XMLHttpRequest",
              "X-CSRF-Token": document.querySelector("[name='csrf-token']")
                .content,
            },
            body: JSON.stringify({
              word,
              weight,
              id,
              destroy,
            }),
          }
        );
        const data = await response.json();
        this.word_weights = data;
        this.processWeights("title", "processedTitle");
        this.processWeights("abstract", "processedAbstract");
      },

      async getAsrId(asrId, beforeAsrId) {
        let url = "";
        if (asrId) {
          url = `/abstract_screenings/<%= params[:abstract_screening_id] %>/screen?asr_id=${asrId}`;
        } else if (beforeAsrId) {
          url = `/abstract_screenings/<%= params[:abstract_screening_id] %>/screen?before_asr_id=${beforeAsrId}`;
        } else {
          url = `/abstract_screenings/<%= params[:abstract_screening_id] %>/screen`;
        }
        const response = await fetch(url, {
          method: "GET",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
          },
        });
        const data = await response.json();

        this.asr.id = data.asr_id;
        if (this.asr.id == null) {
          window.location.href =
            "/abstract_screenings/<%= params[:abstract_screening_id] %>?screening_finished=true";
        }
        this.getAsr();
      },

      async updateAsr(submissionType) {
        if (submissionType === "label") {
          this.showConfirmation(this.asr.label);
        }
        await this.fetchAsr("PATCH", submissionType);
        this.confirmationModal = false;
      },

      async getAsr() {
        this.fetchAsr("GET");
      },

      async fetchAsr(method, submissionType) {
        baseUrl = window.location.href.split("?")[0];
        window.history.pushState("", "", baseUrl);
        const headers = {
          method,
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "X-CSRF-Token": document.querySelector("[name='csrf-token']")
              .content,
          },
        };

        if (method == "PATCH") {
          headers.body = JSON.stringify({
            asr: this.asr,
            submissionType,
          });
        }
        const response = await fetch(
          `/abstract_screening_results/${this.asr.id}`,
          headers
        );
        const data = await response.json();
        if (submissionType !== "notes") {
          this.asr = data.asr;
          this.all_labels = data.all_labels;
          this.citation = data.citation;
          this.options = data.options;
          this.word_weights = data.word_weights;
          this.processWeights("title", "processedTitle");
          this.processWeights("abstract", "processedAbstract");
        }
        if (
          method == "GET" ||
          (method == "PATCH" && submissionType == "label")
        ) {
          this.cps = data.cps;
        }
      },
    }));
  });
</script>
